## Spring Data JPA 영속성 컨텍스트

### 영속성 컨텍스트
- 데이터(엔티티 객체)를 영구적으로 저장할 엔티티 객체를 관리하고 변경 내용을 추적하는 메모리 상의 논리적 공간
- 일종의 캐시 메모리와 같은 역할을 한다
- 즉, 동일한 트랜잭션 내에서 같은 엔티티를 조회할 경우 DB 접근 없이 캐시된 데이터를 반환하여 성능을 최적화한다
- 스프링 JPA가 최초로 엔티티에 접근하면, DB에서 끌어온 엔티티를 영속성 컨텍스트에 등록한다
- 이후 스프링 JPA에서 레파지토리 인터페이스를 통하여 같은 엔티티에 접근하면 DB쿼리를 날리는 게 아닌 이상 영속성 컨텍스트에 있는 데이터를 조회한다
- `@EntityManager`를 이용하여 접근한다
- 그러나 대부분은 스프링 JPA의 레파지토리 인터페이스를 사용한다
- 스프링 JPA가 내부적으로 이 레파지토리 인터페이스 메서드 호출 시 트랜잭션 범위 내에서 EntityManager를 사용하여 영속성 컨텍스트에 접근하고 작업을 수행한다
- 즉, 개발자가 컨텍스트에 직접 접근하기보다 레파지토리를 통해 간접적으로 접근하는 것이 일반적이다


### 영속성
JPA의 엔티티 매니저를 통해 영속성 컨텍스트에 접근할 수 있다. 이때 엔티티 매니저의 영속화에 따라서 객체의 생명주기는 아래와 같이 분리된다

#### 1. 비영속
- 영속성 컨텍스트는 물론 데이터베이스에도 저장되지 않은 **순수한 자바 객체**의 상태
- new 연산자로 객체를 생성한 직후의 객체이며 엔티티 매니저의 관리를 받지 않는다
- `EntityManager.persist(entity)` 메서드를 호출하면 영속 상태로 전환된다

#### 2. 영속 (Persistent)
- 영속성 컨텍스트에 관리되는 상태 
- `EntityManager.find()`, `EntityManager.persist()`, 또는 데이터베이스에서 조회하여 컨텍스트에 로드된 객체가 이 상태가 된다
- JPA의 더티체킹, 쓰기 지연(`persist()`를 호출해도 즉시 DB에 저장되지 않고, 트랜잭션 커밋 시점에 모아서 SQL을 실행) 기능을 사용할 수 있다

#### 3. 준영속
- 영속성 컨텍스트에 저장되었다가 분리된 상태
- 한 번 영속 상태였으므로 식별자(id)값이 존재한다
- 더티 채킹 기능, 지연 로딩 기능을 사용할 수 없다

#### 4. 삭제
- 영속성 컨텍스트와 DB에서 삭제되기 위해 준비된 상태 
- `EntityManager.remove(entity)`를 호출하면 삭제 상태가 된다
- 객체 자체는 여전히 자바 힙 메모리에 존재하지만, 트랜잭션 커밋 시점에 데이터베이스에서 삭제된다


### 영속성 객체
객체를 관리할 때 영속 상태가 좋은 이유는 아래와 같다

#### 1차 캐시
- 영속성 컨텍스트는 DB와 상호작용 하는 1차 캐시의 역할을 한다
- 엔티티를 한 버 조회하는 그 객체는 영속성 컨텍스트 안에 저장되어 트랜잭션이 끝날 때까지 캐시처럼 유지된다
- 한 트랜잭션 안에서 같은 객체를 다시 조회하면 DB를 거치지 않고 바로 캐시에서 가져올 수 있다
- 트랜잭션이 끝나 commit되거나 `flush()`가 일어날 때 기존 상태와 비교해서 변경된 부분을 자동으로 감지(= 더티 채킹)하고, 필요한 경우 DB에 반영
- `flush()` : 영속성 컨텍스트의 변경 사항을 SQL로 변환하여 DB에 전송하는 것. DB에 SQL이 전송되지만, 아직 임시 상태(Rollback 가능)이다. 필요에 따라 수동으로 호출하거나 JPA가 자동으로 호출한다

#### 더티 채킹
- 관리되는(managed) 엔티티가 수정된 것으로 표시되어 있다면, 플러시(flush) 과정에서 UPDATE SQL이 자동으로 생성된다
- 이때 더티 채킹 기능은 엔티티가 처음 로드된 이후 변경되었는지 변경되지 않았는지의 여부를 판단하는 역할을 한다
- 즉, 개발자가 직접 업데이트 쿼리를 관리하지 않더라도 엔티티의 변경 사항을 자동으로 감지하고 DB에 반영해준다

#### 지연 로딩
- **즉시 로딩**의 경우 조회한 객체와 연관된 모든 객체를 한 번에 조회한다
- 연관 관계를 지정할때, (fetch = FetchType.EAGER) 를 통해 즉시 로딩으로 설정할 수 있다
- 예를 들어 MemberFood를 조회할 때 Member와 food를 함께 조회해야 한다면 둘을 함께 조회하기 위한 쿼리문이 나가게 된다
- 그러나 **지연 로딩**은 DB가 아닌 프록시에서 데이터를 가져온다
- 프록시는 실제 엔티티 객체를 상속받아 만들어진 대리(가짜) 객체이다. 프록시 객체는 처음에 껍데기만 가지고 있다. 객체의 id(식별자)값만이 채워져 있고 나머지 필드에는 실제 데이터가 없다. 프록시의 존재로 인해 JPA는 DB 조회 없이 객체 간의 연관 관계를 표현할 수 있다. 메모리에는 껍데기만 올려두고, 정말 필요할 때만 DB에서 데이터를 가져와 성능을 최적화할 수 있다
- 즉, 지연 로딩을 사용하면 Member, food 객체 데이터를 직접 사용하기 전까지는 조회하지 않는다
- 즉시 로딩은 JPQL에서 N+1 문제가 발생할 수 있으므로 가급적 지연 로딩을 사용하는 것을 권장한다

#### N+1 문제의 해결
1. Fetch Join : @Query 어노테이션 내부의 JPQL 문자열에 직접 사용한다. 전체 JPQL 쿼리(JOIN FATCH)를 직적 작성해야 하므로 난이도가 높다. JPA 기본 메소드에는 적영이 불가하며 별도의 @Query 메서드를 만들어야 한다
2. @EntityGraph : Spring Data JPA Repository 메서드 위에 직접 사용한다. @EntityGraph 뒤에 연관 필드의 이름만 문자열만 나열하면 되므로 간편하다. findAll(), findById() 등 기본 메서드를 오버라이드하여 사용할 수 있다. Fetch Join의 간편 버전이라고 생각하면 이해가 쉽다

<br/>

## JPQL
### JPQL
JPQL은 JPA의 일부로 쿼리를 데이터베이스의 테이블이 아닌 JPA 엔티티, 즉 객체를 대상으로 작성하는 객체 지향 쿼리 언어이다. 즉, JPQL을 사용함으로써 객체 지향적인 특징을 반영한 쿼리를 날릴 수 있게 된다! JPQL의 사용법은 아래 두 가지의 선택지로 나뉜다

1. EntityManager 인터페이스
2. repository 인터페이스

이 중 repository 인터페이스스는 간결함과 일관성 유지에 탁월하고 스프링 JPA에서 더 일반적으로 사용하는 방식이다. repository 인터페이스를 활용하여 JPQL을 날리는 방법은 크게 아래의 2가지가 있다

### 1. 메소드 이름으로 쿼리를 생성
- 스프링 JPA는 메소드의 이름을 기준으로 자동으로 쿼리를 생성해준다 
- 원하는 레파지토리 클래스에 JpaRepository<T, ID>를 상속한다
- 이후 요구사항에 맞춘 메소드를 정의한다
- `List<Member> findByName(String name);`처럼 메소드를 정의하면 String으로 된 name을 받아 테이블 내 name이 일치하는 Member들만을 list로 받아온다
- 메소드의 이름만 규칙에 맞게 작성하면 스프링 JAP가 메소드의 이름을 해석하여 JPQL, SQL 쿼리를 자동으로 생성한다 → 개발자가 직접 쿼리를 작성할 필요가 없다
- `save(entity)`, `findById(id)`, `existsById(id)`, `delete(entity)`, `deleteById(id)` 등의 기본 메소드들은 메소드명을 정의하지 않고도 바로 사용할 수 있다

### 2. `@Query` 어노테이션
- JPQL을 직접 작성하는 방법
- 자동 쿼리로 해결하지 못하는 복잡한 조건이나 커스터마이징이 필요한 쿼리를 작성할 때 사용한다
```java
    @Query("select m from Member m where m.name = :name and m.deleted_at is null")
    List<Member> findActiveMember(@Param("name") String name);
```
- `@Query` 어노테이션을 활용하여 이름과 상태를 조건으로 조회하는 JPQL 쿼리를 작성하고, `@Param` 어노테이션을 통해 JPQL 쿼리에서 사용되는 `:name` 파라미터를 메서드의 인자와 연결합니다.
- `nativeQuery = true` 파라미터를 통해 JPQL의 쿼리문이 아닌 SQL문을 실행할 수 있다

### 메소드명 규칙
- `find…By`, `exists…By` 같은 앞부분이 주제를 정의
- `By` 이후는 실제 조건을 작성한다
- `And`, `Or`은 조건을 연결을 위해 사용하며 
- `Between`, `LessThan`, `GreaterThan`, `Like` 같은 연산자도 지원된다
- `IgnoreCase`를 이용해 대소문자를 무시하거나 `OrderBy`로 정렬을 지정할 수도 있다
- 속성이 중첩되어 있어도 탐색이 가능하며, 필요하면 언더스코어(`_`)로 경로를 명시할 수 있다

```java
// Order 엔티티의 'member' 필드에 있는 'name' 속성을 기준으로 찾는다.
List<Order> findByMember_Name(String name);
```

- 페이징(`Pageable`)이나 정렬(`Sort`), 제한(`Limit`) 파라미터를 추가하면 쿼리를 동적으로 조정할 수도 있다

> 그러나 메소드 이름만으로 만들 수 있는 쿼리에는 한계가 있어서 복잡한 조건이나 동적 쿼리는 결국 @Query나 QueryDSL 같은 도구가 필요하다. 또한 자동으로 생성된 쿼리가 항상 최고의 효율을 내는 것은 아니므로 최적화를 위해 실행되는 쿼리를 꼭 확인하고 분석해봐야 한다!

<br/>

## QueryDSL
### QueryDSL
- SQL, JPQL 등을 Java 코드를 사용하여 타입 안정성을 보장하며 생성할 수 있도록 도와주는 오픈 소스 라이브러리
- 스프링 JPA의 메서드 이름 쿼리 생성이나 @Query 어노테이션 방식만으로는 처리하기 어려운 쿼리 문제를 해결하기 위해 주로 사용된다
- 코드 기반의 쿼리 빌더를 제공하기 때문에, 컴파일 시점에 쿼리의 오류를 잡을 수 있으며 동적 쿼리 작성이 편리하고, 메서드 체이닝을 통한 복잡한 쿼리 작성에 유리하다

#### QueryDSL의 장점
1. 타입 안전성 확보 : 일반적인 JPQL은 쿼리를 문자열로 작성하기 때문에, 엔티티나 필드 이름에 오타가 있어도 컴파일 시점에서는 오류를 잡을 수 없다 → QueryDSL은 엔티티를 기반으로 자동으로 생성되는 Q 클래스라는 정적 객체를 사용한다. 이 Q 클래스의 필드를 메서드 체이닝으로 호출하여 쿼리를 작성하므로, 오타가 발생하면 컴파일 시점에 즉시 오류를 발견할 수 있다  
2. 동적 쿼리 작성 용이 : QueryDSL은 `BooleanBuilder`나 `where()` 절의 다중 파라미터를 활용하여 조건이 null일 경우 해당 조건을 자동으로 무시하는 등 동적 쿼리의 작성을 돕는다
3. 코드 가독성과 재사용성 : select, from, where, join, groupBy, orderBy 등의 SQL 키워드를 자바 메서드 체이닝 방식으로 사용하므로, 쿼리가 훨씬 직관적이고 가독성이 높아진다. 복잡한 조건이나 자주 사용되는 조건은 별도의 메서드(BooleanExpression 반환)로 추출하여 다른 쿼리에서 재사용할 수 있다

#### 메소드 체이닝
- 객체의 메소드를 호출한 후 해당 메소드가 다시 그 객체 자신을 반환하여 반환된 객체를 이용해 또 다른 메소드들을 체인처럼 호출하는 코딩 기법
- 체이닝을 가능하게 하려면 메소드가 작업을 수행한 후 void를 반환하는 대신 return this;를 사용하여 자기 자신을 반환해야 한다
- 메소드들이 자기 자신을 반환하면 메소드가 메소드를 호출하는 느낌으로 사용할 수 있다
- A만약 라는 객체가 자기 자신을 호출하는 method1과 method2를 가지고 있다면 A.method1().method2 이런 식으로 코드를 이어 작성할 수 있다
- 메소드 체이닝은 코드를 간결하고 가독성 있게 만들며 특히 빌더 패턴이나 DSL(Domain Specific Language) 라이브러리에서 광범위하게 사용된다

#### 💡 추가 개념
- 빌더 패턴 : 복잡한 객체를 생성할 때 사용되는 디자인 패턴 중 하나. 생성할 객체의 필수값을 한 번에 받고 선택 값은 메서드 체이닝을 통해 유연하게 설정할 수 있도록 한다. 객체 새성 시 매개변수가 너무 많아 생성자가 복잡해지는 문제를 해결하고 가독성을 높인다
- DLS : 특정 영역(Domain)에 특화되어 설계된 언어나 구문을 의미한다. 기존 프로그래밍 언어의 문법을 활용하는 내부 DSL(QueryDSL 등), 완전히 독립된 문법과 파서를 가진 외부 DSL(SQL, HTML, CSS 등)로 나뉜다
- 파서 : 언어의 문법 규칙(Grammar)에 따라 작동하며, 복잡한 문자열을 컴퓨터가 처리하기 쉬운 구조화된 데이터 형태(보통 트리 구조)로 변환한다

### 동적 쿼리
- 실행 시점에 쿼리의 일부가 변경될 수 있는 쿼리
- 예를 들어 지역명으로 가게를 검색하는 쿼리에서 지역명 자리를 비워두었다가 실행 시점에 원하는 지역명을 채우는 등의 식으로 활용할 수 있다

<br/>

