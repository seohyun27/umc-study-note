## API

### API
- Application Programming Interface
- 어플리케이션을 프로그래밍할 때 사용되는 인터페이스

### REST API
- Representational State Transfer
- HTTP를 기반으로 하는 웹 서비스 아키텍처
- HTTP 메소드와 자원을 이용해 서로 간의 통신을 주고 받는 방법이다

### HTTP
- 웹에서 클라이언트와 서버가 서로 정보를 주고받을 때 사용하는 통신 규칙
- 통신 규칙 안에는 여러 메서드가 존재한다. 그 중 대표적인 것이 GET, POST, PUT, PATCH, DELETE
1. GET : 데이터 **조회**하기. 서버에 있는 데이터를 요청해서 받아온다. 멱등성을 가지고 있어 여러 번 조회해도 리소스는 변하지 않는다. 서버로 데이터를 보내야 할 경우(조회를 원하는 회원의 id 등) 쿼리 스트링을 통해 전달된다. 쿼리 스트링은 무방비에 노출되므로 조심해야 한다
2. POST : 새 데이터 **생성**하기. 메시지 바디를 통해 데이터를 전달한다. 쿼리 파라미터는 key-value 형식으로 되어 있다
3. PUT : 서버의 데이터를 **전체적으로 수정하거나 교체**하기. 리소스를 완전히 대체하는 개념이다. 있으면 대체하고 없으면 생성한다.
4. PATCH : PUT과 같이 리소스를 수정한다. 단, 리소스를 완전히 대체하지 않고 **부분적으로 변경**한다. PATCH 메소드를 지원하지 않는 서버가 존재한다. 멱등성을 지니지 않는다.
5. DELETE : 서버의 데이터를 **삭제**하기. 

<br/>

## 멱등성과 비멱등성
### 멱등성
- 여러 번 수행해도 한 번 수행한 것과 결과가 같은 성질
- 조회, 삭제, 리소스 교체의 경우 몇 번을 수행하든 같은 결과를 가진다 → 멱등성 O
- 생성(동일한 내용을 가진 다른 리소스가 생성됨), 리소스의 부분적 수정(좋아요의 수를 1씩 증가시키는 등의 작업이 가능함)의 경우 수행할 때마다 다른 결과를 가진다 → 멱등성 X

### 비멱등성 (Non-idempotent)
- 수행할 때마다 결과가 달라지거나 서버 상태가 변하는 성질

<br/>

## HTTP 요청과 응답
### HTTP 요청
- 클라이언트가 서버에게 보내는 메시지
- [요청 라인 + 헤더 + 바디]의 구조를 가진다
- 그 중 가장 앞의 요청 라인의 경우 [메소드 + 요청 대상(요청하는 리소스의 경로, URI) + HTTP 버전]의 구조를 가진다
- 바디의 경우 서버에 전달할 실제 데이터를 담는다
- 즉 GET, POST, PUT, DELETE 등의 메소드는 요청 라인의 맨앞에 명시된다!
- GET, DELETE의 경우 URL 경로 혹은 쿼리 파라미터로 리소스의 ID 값이 전달된다
- POST, PUT, PATCH의 경우 바디에 JSON으로 리소스 정보를 전달한다
```http
// POST 요청 예시
POST /users HTTP/1.1
Host: example.com
Content-Type: application/json

{
"name": "김서현",
"email": "canna7610@gmail.com"
}
```

### HTTP 응답
- 서버가 요청을 처리한 후 클라이언트에게 보내는 메시지
- [상태 라인 + 헤더 + 바디]의 구조를 가진다
- 그 중 가장 앞의 상태 라인의 경우 [HTTP 버전 + 상태 코드(200번, 404번, 500번 등) + 상태 텍스트]의 구조를 가진다
- 바디의 경우 클라이언트에게 전달할 실제 데이터를 담는다 (GET 요청이 성공했을 때의 데이터, 오류 발생 시의 오류 메시지 등등)
```http
// 위 POST 요청에 대한 성공 응답 예시
HTTP/1.1 201 Created
Content-Type: application/json
Content-Length: 50

{
"id": 1,
"name": "김서현",
"email": "canna7610@gmail.com"
}
```

<br/>

## URI, URL, URN
### URI
- URL과 URN을 포함하는 가장 큰 개념
- 인터넷의 자원을 유일하게 식별할 수 있는 모든 문자열을 의미한다
- 자원을 구분할 수만 있다면 모두 URI에 속한다

### URL
- 통합 자원 위치
- 자원이 어디에 있는지 해당 '위치'를 알려주는 주소(문자열)이다
- 주로 웹에서 사용된다
- https:// 같은 프로토콜(접근 방식)과 example.com 같은 서버의 도메인, 8080과 같은 포트 번호, /products/11 같은 경로 정보, key=value 형식의 쿼리 정보가 포함된다
- 즉, 자원을 찾아가는 방법과 길이 명시되어 있다
- 현재의 웹 표준에서는 URI와 URL을 별도로 구분하지 않고 URL이라는 용어로 통일하여 사용한다

### URN
- 자원의 위치와 상관없이 부여된 고유한 이름
- 자원의 위치가 바뀌더라도 URN의 값은 변하지 않는다
- 그러나 URN만으로는 실제 자원이 있는 곳을 찾기 힘들어 현재는 거의 사용하지 않는다

<br/>

## RESTful API Endpoint
서버의 API가 외부에 노출되어 **클라이언트**가 통신할 수 있는 최종 접점. API 서버가 제공하는 기능들을 사용하기 위해 접근하는 URL이다
- 서버는 회원 등록, 회원 관리, 회원 삭제와 같은 다양한 API를 가지고 있다
- 클라이언트는 이 기능들을 사용하기 위해 정해진 주소(URL)로 자신의 요청을 보내야 한다
- 이째의 URL이 바로 엔드포인트가 된다
예를 들어 사용자 정보를 관리하는 RESTful API가 존재한다면 다음과 같은 엔드포인트들을 가질 수 있다
- GET /users : 모든 사용자 목록 조회
- GET /users/11 : ID가 11인 사용자 정보 조회
- POST /users : 새로운 사용자 생성
- DELETE /users/11 : ID가 11인 사용자 삭제

### 설계 규칙
1. URI에 동사가 포함되어선 안 된다
2. 단어의 구분이 필요한 경우 하이픈(-)을 사용한다
3. 자원은 기본적으로 복수형으로 표현한다
4. 단 하나의 자원만을 명시적으료 표현하기 위해서는 /users/{user_id}와 같이 식별값을 추가적으로 사용한다
5. 자원 간의 연관 관계가 있을 경우 이를 URI에 표현한다

### 설계 예시
회원 가입, 로그인, 탈퇴의 API URL Endpoint를 설계한다고 가정하자. 이때 인증 로직은 실제 비즈니스 로직과 별도로 처리되는 경우가 많다 → 인증과 관련된 로직의 엔드 포인트는 /auth/...으로 나머지 기능들의 엔드포인트는 /api/...로 나뉘지는 편이 많다

#### 1. 회원 가입
- 데이터를 생성하는 POST 요청
- `POST /auth/users` 또는 `POST /auth/users/signup`
- 회원 가입 시점에서 해당 유저를 식별할 id값이 존재하지 않으므로 식별값을 사용하지 않는다
- 만약 해당 서버의 도메인 주소가 `https://umc.com`일 경우, POST `https://umc.com/auth/users` 쪽으로 회원가입을 요청하는 것이다

#### 2. 로그인
- 로그인 정보는 반드시 본문에 담아 보내야 하므로(보안 문제) POST 메소드를 사용한다
- 또한 로그인 요청마다 새 세션(or 토큰)을 발급하고 로그인 기록을 남겨야 하므로 멱등성을 가지지 않는(非멱등성의) 메소드를 사용해야 한다
- 즉 로그인의 경우 '인증 세션을 생성'하는 서버의 상태 변경으로 보는 것이 적합하다
- `POST /auth/users/login` 또는 `POST /auth/login`

#### 3. 회원 탈퇴
- 회원 탈퇴를 DELETE로 구현하는 경우 탈퇴와 동시에 회원 데이터를 삭제하는 하드 딜리트가 된다
- 만약 하드 딜리트를 원하는 경우 엔드포인트를 `DELETE /api/users/me` 또는 `DELETE /api/users/{user-id}`로 잡는다
- 소프트 딜리트를 원하는 경우 `PATCH /api/users/me` 또는 `PATCH /api/users/{user-id}`를 사용할 수 있다
- 이때 요청 본문에 사용자의 상태를 활성화 상태에서 비활성화 상태로 부분 수정(PATCH)한다
- 회원 탈퇴에서 /auth가 아닌 /api를 쓰는 이유 : 회원 가입, 로그인은 아직 인증되지 않은 상태에서 인증을 받기 위한 과정이므로 /auth 경로가 적합. 반면 회원 탈퇴는 이미 로그인하여 인증된 사용자가 자신의 정보를 수정하는 행위이므로 비즈니스 로직을 다루는 /api 경로 아래에 두는 것이 더 일반적인 설계이다
- /auth는 서비스에 들어가기 위한 관문 역할을 하며 회원가입, 로그인, 토근 재발급 등의 인증되지 않은 상태(로그인 전)을 관리한다

> /auth을 통해 인증이 완료된 사용자는 서버 내부의 /api를 이용해 여러 기능들을 사용할 수 있다!

### 리소스 간 연관 관계가 있는 경우
#### 1:N 관계
- 유저(교사)와 교과목은 1:N 관계
- 이때 계층 관계는 교사 → 교과목 순서이므로 엔드포인트 역시 `teachers/subjects`로 잡는다
- 만약 특정 교사의 교과목을 보고 싶다면 `/teachers/id/subjects`로 설계가 가능하다
- 만약 특정 교과목을 보고 싶다면 `/teachers/subjects/id`, 특정 교사의 특정 교과목을 보고 싶다면 `/teachers/id/subjects/id`로 설계가 가능하다

#### N:M 관계
- N:M 관계의 경우 계층 관계를 파악하기 힘들다
- users/subjects 혹은 subjects/users 중에 하나를 선택할 수 있다
- 만약 비즈니스 로직상 더 중요한 대상이 존재한다면 해당 대상을 앞에 두는 방식을 사용할 수 있다 (ex. 게시글 → 해시태그)
- 이 경우 둘 사이의 순서를 정해두고 항상 정해진 순서에 따라 표기한다

### 쿼리 파라미터 방식
N:M 관계를 해결하는 한 가지 방식
1. 각 리소스를 독립접으로 조회한다. 모든 유저 목록은 /users로 모든 과목 목록은 /subjects로 조회한다
2. 만약 특정 유저를 가져오고 싶다면 `/users/{user-id}`의 엔드포인트를 사용할 수 있다
3. 특정 사용의 모든 과목을 얻고 싶다면 user-id를 '쿼리 파라미터'로 넘겨 결과 필터링이 가능하다 → `/subjects?user_id={user_id}` (쿼리 파라미터의 경우 하이픈 대신 언더바를 사용하는 것이 보편적이다)
4. 만약 특정 과목을 가져오고 싶다면 `/subjects/{subjects-id}`의 엔드포인트를 사용할 수 있다 
5. 특정 과목의 모든 유저를 얻고 싶다면 전체 유저를 가져온 뒤 특정 과목을 수강하는 유저만을 필터링할 수 있다 → `/user?subjects_id={subjects_id}`
> 필요에 따라 **경로 변수**와 **쿼리 파라미터**를 적절히 사용할 것

### 쿼리 파라미터 방식의 구현
- 쿼리 파라미터 방식은 스프링 부트에서 `@RequestParam` 어노테이션으로 구현할 수 있다
- 디토 정보를 받아올 때 `@RequestParam`을 이용해 쿼리 정보를 함께 받아올 수 있다
- 이때 `(required = false)` 옵션을 사용하면 쿼리 파라미터가 있을 수도 있고 없을 수도 있다
- api 메소드 작성 시 `@RequestParam(required = false) Long userId`을 이용해 유저 아이디를 파라미터로 받아오고 `if (userId != null)`을 이용해 쿼리의 존재 유무를 판단한다
> 다대다 관계의 중간 테이블과 API 설계 : 중간 테이블은 서버에서 처리하는 것. API를 이용하는 **클라이언트 측에서는 중간 테이블의 존재를 알고 싶지도 않고 알 필요도 없다**.

<br/>

## 전체 API 설계
### HTTP 요청의 구성 요소
HTTP 요청의 구성 요소는 아래와 같다
1. 경로 변수
2. 쿼리 문자열
3. 요청 바디
4. 요청 헤더 <br/>

이 중 API 엔드포인트와 연관있는 것은 경로 변수 뿐이다. 그러나 API 설계를 위해서는 엔드포인트를 포함해 위의 4가지를 모두 신경써야 한다

### 1. 경로 변수
- 경로 변수는 특정 대상을 지목할 때 사용한다
- `GET /users/articles/{article-id}`처럼 게시글의 식별값을 넘겨 특정 대상을 지목할 수 있다
- 여기서 article-id는 게시글의 기본키가 된다
- API 명세서 작성 시 {article-id} 대신 하이픈을 생략하고 {articleId}로 표현할 수도 있다

### 2. 쿼리 스트링
- 쿼리 스트링은 보통 GET 메소드의 '검색 조회'에서 사용된다
- ?의 뒤에 &로 구분해 여러개의 값을 넘길 수 있다
```api
GET /users/articles?name=umc&owner=ddol
```
- 이때 쿼리 스트링 자레는 API의 엔드포인트에 포함되지 않는다
- 엔드포인트 설계와는 별개로 고민하는 것이 좋을 것이다

### 3. 요청 바디
- POST, PUT, PATCH의 경우 요청 바디에 json 혹은 form-data의 형태로 리소스의 정보를 전달한다
```json
{
"name" : "김서현",
"phoneNum" : "010-1234-5678",
"nickName" : "eno",
}
```

### 4. 요청 헤더
- 전송에 관련된 기타 정보(메타 데이터)들이 담기는 공간이다
- Request Body의 형식이 json이라는 것 등등의 정보가 담긴다
- 인증에 필요한 데이터를 이 헤더에 넣는 경우도 존재한다
- `Authorization : Bearer {accessToken}` : accessToken은 로그인 된 사용자가 본인이 로그인 상태를 알려주는 것으로, 보통 Authorization이라는 키에 대한 값으로 헤더에 담겨 서버에 전송된다



